# Um programa de retrocesso em Python para resolver o problema do Sudoku


# Uma funcao de utilitario para imprimir a grade
def print_grid(arr): 
	for i in range(9): 
		for j in range(9): 
			print arr[i][j], 
		print ('n') 

		
# Funcao para localizar a entrada na grade que ainda nao e usada
# Procura na grade para encontrar uma entrada que ainda nao foi atribuida. E se
# encontrado, a linha de parametros de referencia, col sera definida como o local
# que nao foi atribuido e true e retornado. Se nenhuma entrada nao atribuida
# permanece, falso e retornado.
# 'l' e uma variavel de lista que foi passada a partir da funcao resolve_sudoku
# para acompanhar o incremento de linhas e colunas
def find_empty_location(arr,l): 
	for row in range(9): 
		for col in range(9): 
			if(arr[row][col]==0): 
				l[0]=row 
				l[1]=col 
				return True
	return False

# Retorna um booleano que indica se alguma entrada atribuida
# na linha especificada corresponde ao numero fornecido. 
def used_in_row(arr,row,num): 
	for i in range(9): 
		if(arr[row][i] == num): 
			return True
	return False

# Retorna um booleano que indica se alguma entrada atribuida
# na coluna especificada corresponde ao numero fornecido.
def used_in_col(arr,col,num): 
	for i in range(9): 
		if(arr[i][col] == num): 
			return True
	return False

# Retorna um booleano que indica se alguma entrada atribuida
# dentro da caixa 3x3 especificada corresponde ao numero especificado
def used_in_box(arr,row,col,num): 
	for i in range(3): 
		for j in range(3): 
			if(arr[i+row][j+col] == num): 
				return True
	return False

# Verifica se sera legal atribuir numero a linha especificada, col
# Retorna um booleano que indica se sera legal atribuir
# numero para a linha especificada, local da coluna.
def check_location_is_safe(arr,row,col,num): 
	
# Verifique se 'num' ainda nao esta colocado na linha atual,
# coluna atual e caixa 3x3 atual
	return not used_in_row(arr,row,num) and not used_in_col(arr,col,num) and not used_in_box(arr,row - row%3,col - col%3,num) 

# Pega uma grade parcialmente preenchida e tenta atribuir valores a
# todos os locais nao atribuidos de forma a atender aos requisitos
# para solucao Sudoku (sem duplicacao em linhas, colunas e caixas)
def solve_sudoku(arr): 
	
    # 'l' e uma variavel de lista que mantem o registro de linha e col na funcao find_empty_location	 
	l=[0,0] 
	
	# Se nao houver um local nao atribuido, terminamos	 
	if(not find_empty_location(arr,l)): 
		return True
	
# Atribuindo valores de lista as linhas e colunas que obtivemos da funcao acima
	row=l[0] 
	col=l[1] 
	
	# considere os digitos 1 a 9
	for num in range(1,10): 
		
		#se parece promissor
		if(check_location_is_safe(arr,row,col,num)): 
			
			# faca uma tarefa experimental
			arr[row][col]=num 

			# retorno, se tiver sucesso, sim!
			if(solve_sudoku(arr)): 
				return True

		# falha, desfaca e tente novamente
			arr[row][col] = 0
			
	# isso aciona o retorno		 
	return False

# Funcao principal do driver para testar as funcoes acima
if __name__=="__main__": 
	
# Criando uma matriz 2D para a grade
	grid=[[0 for x in range(9)]for y in range(9)] 
	
# atribuindo valores a grade
	grid=[[3,0,6,5,0,8,4,0,0], 
		[5,2,0,0,0,0,0,0,0], 
		[0,8,7,0,0,0,0,3,1], 
		[0,0,3,0,1,0,0,8,0], 
		[9,0,0,8,6,3,0,0,5], 
		[0,5,0,0,9,0,6,0,0], 
		[1,3,0,0,0,0,2,5,0], 
		[0,0,0,0,0,0,0,7,4], 
		[0,0,5,2,0,6,3,0,0]] 
	
	# se for bem sucedido, imprima
	if(solve_sudoku(grid)): 
		print_grid(grid) 
	else: 
		print "No solution exists"
